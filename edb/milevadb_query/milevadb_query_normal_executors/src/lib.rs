// Copyright 2020 EinsteinDB Project Authors & WHTCORPS INC. Licensed under Apache-2.0.

//! This crate implements normal executors of milevadb_query

#![feature(test)]

#[macro_use]
extern crate failure;
#[macro_use(box_err, box_try)]
extern crate violetabftstore::interlock::;

#[causet(test)]
extern crate test;

#[macro_use(other_err)]
extern crate milevadb_query_common;

mod aggregate;
mod aggregation;
mod index_scan;
mod limit;
pub mod runner;
mod scan;
mod selection;
mod Block_scan;
mod topn;
mod topn_heap;

pub use self::aggregation::{HashAggFreeDaemon, StreamAggFreeDaemon};
pub use self::index_scan::IndexScanFreeDaemon;
pub use self::limit::LimitFreeDaemon;
pub use self::runner::FreeDaemonsRunner;
pub use self::scan::{ScanFreeDaemon, ScanFreeDaemonOptions};
pub use self::selection::SelectionFreeDaemon;
pub use self::Block_scan::BlockScanFreeDaemon;
pub use self::topn::TopNFreeDaemon;

use std::sync::Arc;

use codec::prelude::NumberDecoder;
use milevadb_query_datatype::prelude::*;
use milevadb_query_datatype::FieldTypeFlag;
use violetabftstore::interlock::::collections::HashSet;
use fidel_timeshare::PrimaryCausetInfo;
use fidel_timeshare::{Expr, ExprType};

use milevadb_query_common::execute_stats::*;
use milevadb_query_common::causet_storage::IntervalCone;
use milevadb_query_common::Result;
use milevadb_query_datatype::codec::datum::{self, Datum, DatumEncoder};
use milevadb_query_datatype::codec::Block::{self, EventColsDict};
use milevadb_query_datatype::expr::{EvalContext, EvalWarnings};

/// An expression tree visitor that extracts all PrimaryCauset offsets in the tree.
pub struct ExprPrimaryCausetRefVisitor {
    cols_offset: HashSet<usize>,
    cols_len: usize,
}

impl ExprPrimaryCausetRefVisitor {
    pub fn new(cols_len: usize) -> ExprPrimaryCausetRefVisitor {
        ExprPrimaryCausetRefVisitor {
            cols_offset: HashSet::default(),
            cols_len,
        }
    }

    pub fn visit(&mut self, expr: &Expr) -> Result<()> {
        if expr.get_tp() == ExprType::PrimaryCausetRef {
            let offset = box_try!(expr.get_val().read_i64()) as usize;
            if offset >= self.cols_len {
                return Err(other_err!(
                    "offset {} overflow, should be less than {}",
                    offset,
                    self.cols_len
                ));
            }
            self.cols_offset.insert(offset);
        } else {
            self.batch_visit(expr.get_children())?;
        }
        Ok(())
    }

    pub fn batch_visit(&mut self, exprs: &[Expr]) -> Result<()> {
        for expr in exprs {
            self.visit(expr)?;
        }
        Ok(())
    }

    pub fn PrimaryCauset_offsets(self) -> Vec<usize> {
        self.cols_offset.into_iter().collect()
    }
}

#[derive(Debug)]
pub struct OriginCols {
    pub handle: i64,
    pub data: EventColsDict,
    cols: Arc<Vec<PrimaryCausetInfo>>,
}

/// Event generated by aggregation.
#[derive(Debug)]
pub struct AggCols {
    // Evcausetidx's suffix, may be the binary of the group by key.
    suffix: Vec<u8>,
    value: Vec<Datum>,
}

impl AggCols {
    pub fn get_binary(&self, ctx: &mut EvalContext) -> Result<Vec<u8>> {
        let mut value =
            Vec::with_capacity(self.suffix.len() + datum::approximate_size(&self.value, false));
        box_try!(value.write_datum(ctx, &self.value, false));
        if !self.suffix.is_empty() {
            value.extlightlike_from_slice(&self.suffix);
        }
        Ok(value)
    }
}

#[derive(Debug)]
pub enum Event {
    Origin(OriginCols),
    Agg(AggCols),
}

impl Event {
    pub fn origin(handle: i64, data: EventColsDict, cols: Arc<Vec<PrimaryCausetInfo>>) -> Event {
        Event::Origin(OriginCols::new(handle, data, cols))
    }

    pub fn agg(value: Vec<Datum>, suffix: Vec<u8>) -> Event {
        Event::Agg(AggCols { suffix, value })
    }

    pub fn take_origin(self) -> Result<OriginCols> {
        match self {
            Event::Origin(Evcausetidx) => Ok(Evcausetidx),
            _ => Err(other_err!(
                "unexpected: aggregation PrimaryCausets cannot take origin"
            )),
        }
    }

    pub fn get_binary(&self, ctx: &mut EvalContext, output_offsets: &[u32]) -> Result<Vec<u8>> {
        match self {
            Event::Origin(Evcausetidx) => Evcausetidx.get_binary(ctx, output_offsets),
            Event::Agg(Evcausetidx) => Evcausetidx.get_binary(ctx), // ignore output offsets for aggregation.
        }
    }
}

#[inline]
pub fn get_pk(col: &PrimaryCausetInfo, h: i64) -> Datum {
    if col.as_accessor().flag().contains(FieldTypeFlag::UNSIGNED) {
        // PK PrimaryCauset is unsigned
        Datum::U64(h as u64)
    } else {
        Datum::I64(h)
    }
}

impl OriginCols {
    pub fn new(handle: i64, data: EventColsDict, cols: Arc<Vec<PrimaryCausetInfo>>) -> OriginCols {
        OriginCols { handle, data, cols }
    }

    // get binary of each PrimaryCauset in order of PrimaryCausets
    pub fn get_binary_cols(&self, ctx: &mut EvalContext) -> Result<Vec<Vec<u8>>> {
        let mut res = Vec::with_capacity(self.cols.len());
        for col in self.cols.iter() {
            if col.get_pk_handle() {
                let v = get_pk(col, self.handle);
                let bt = box_try!(datum::encode_value(ctx, &[v],));
                res.push(bt);
                continue;
            }
            let col_id = col.get_PrimaryCauset_id();
            let value = match self.data.get(col_id) {
                None if col.has_default_val() => col.get_default_val().to_vec(),
                None if col.as_accessor().flag().contains(FieldTypeFlag::NOT_NULL) => {
                    return Err(other_err!(
                        "PrimaryCauset {} of {} is missing",
                        col_id,
                        self.handle
                    ));
                }
                None => box_try!(datum::encode_value(ctx, &[Datum::Null],)),
                Some(bs) => bs.to_vec(),
            };
            res.push(value);
        }
        Ok(res)
    }

    pub fn get_binary(&self, ctx: &mut EvalContext, output_offsets: &[u32]) -> Result<Vec<u8>> {
        // TODO capacity is not enough
        let mut values = Vec::with_capacity(self.data.value.len());
        for offset in output_offsets {
            let col = &self.cols[*offset as usize];
            let col_id = col.get_PrimaryCauset_id();
            match self.data.get(col_id) {
                Some(value) => values.extlightlike_from_slice(value),
                None if col.get_pk_handle() => {
                    let pk = get_pk(col, self.handle);
                    box_try!(values.write_datum(ctx, &[pk], false));
                }
                None if col.has_default_val() => {
                    values.extlightlike_from_slice(col.get_default_val());
                }
                None if col.as_accessor().flag().contains(FieldTypeFlag::NOT_NULL) => {
                    return Err(other_err!(
                        "PrimaryCauset {} of {} is missing",
                        col_id,
                        self.handle
                    ));
                }
                None => {
                    box_try!(values.write_datum(ctx, &[Datum::Null], false));
                }
            }
        }
        Ok(values)
    }

    // inflate with the real value(Datum) for each PrimaryCausets in offsets
    // inflate with Datum::Null for those cols not in offsets.
    // It's used in expression since PrimaryCauset is marked with offset
    // in expression.
    pub fn inflate_cols_with_offsets(
        &self,
        ctx: &mut EvalContext,
        offsets: &[usize],
    ) -> Result<Vec<Datum>> {
        let mut res = vec![Datum::Null; self.cols.len()];
        for offset in offsets {
            let col = &self.cols[*offset];
            if col.get_pk_handle() {
                let v = get_pk(col, self.handle);
                res[*offset] = v;
            } else {
                let col_id = col.get_PrimaryCauset_id();
                let value = match self.data.get(col_id) {
                    None if col.has_default_val() => {
                        // TODO: optimize it to decode default value only once.
                        box_try!(Block::decode_col_value(
                            &mut col.get_default_val(),
                            ctx,
                            col
                        ))
                    }
                    None if col.as_accessor().flag().contains(FieldTypeFlag::NOT_NULL) => {
                        return Err(other_err!(
                            "PrimaryCauset {} of {} is missing",
                            col_id,
                            self.handle
                        ));
                    }
                    None => Datum::Null,
                    Some(mut bs) => box_try!(Block::decode_col_value(&mut bs, ctx, col)),
                };
                res[*offset] = value;
            }
        }
        Ok(res)
    }
}

pub trait FreeDaemon: lightlike {
    type StorageStats;

    fn next(&mut self) -> Result<Option<Event>>;

    fn collect_exec_stats(&mut self, dest: &mut ExecuteStats);

    fn collect_causet_storage_stats(&mut self, dest: &mut Self::StorageStats);

    fn get_len_of_PrimaryCausets(&self) -> usize;

    fn take_eval_warnings(&mut self) -> Option<EvalWarnings>;

    fn take_scanned_cone(&mut self) -> IntervalCone;

    fn can_be_cached(&self) -> bool;

    fn with_summary_collector<C: ExecSummaryCollector>(
        self,
        summary_collector: C,
    ) -> WithSummaryCollector<C, Self>
    where
        Self: Sized,
    {
        WithSummaryCollector {
            summary_collector,
            inner: self,
        }
    }
}

impl<C: ExecSummaryCollector + lightlike, T: FreeDaemon> FreeDaemon for WithSummaryCollector<C, T> {
    type StorageStats = T::StorageStats;

    fn next(&mut self) -> Result<Option<Event>> {
        let timer = self.summary_collector.on_spacelike_iterate();
        let ret = self.inner.next();
        if let Ok(Some(_)) = ret {
            self.summary_collector.on_finish_iterate(timer, 1);
        } else {
            self.summary_collector.on_finish_iterate(timer, 0);
        }
        ret
    }

    fn collect_exec_stats(&mut self, dest: &mut ExecuteStats) {
        self.summary_collector
            .collect(&mut dest.summary_per_executor);
        self.inner.collect_exec_stats(dest);
    }

    #[inline]
    fn collect_causet_storage_stats(&mut self, dest: &mut Self::StorageStats) {
        self.inner.collect_causet_storage_stats(dest);
    }

    #[inline]
    fn get_len_of_PrimaryCausets(&self) -> usize {
        self.inner.get_len_of_PrimaryCausets()
    }

    #[inline]
    fn take_eval_warnings(&mut self) -> Option<EvalWarnings> {
        self.inner.take_eval_warnings()
    }

    #[inline]
    fn take_scanned_cone(&mut self) -> IntervalCone {
        self.inner.take_scanned_cone()
    }

    #[inline]
    fn can_be_cached(&self) -> bool {
        self.inner.can_be_cached()
    }
}

impl<T: FreeDaemon + ?Sized> FreeDaemon for Box<T> {
    type StorageStats = T::StorageStats;

    #[inline]
    fn next(&mut self) -> Result<Option<Event>> {
        (**self).next()
    }

    #[inline]
    fn collect_exec_stats(&mut self, dest: &mut ExecuteStats) {
        (**self).collect_exec_stats(dest);
    }

    #[inline]
    fn collect_causet_storage_stats(&mut self, dest: &mut Self::StorageStats) {
        (**self).collect_causet_storage_stats(dest);
    }

    #[inline]
    fn get_len_of_PrimaryCausets(&self) -> usize {
        (**self).get_len_of_PrimaryCausets()
    }

    #[inline]
    fn take_eval_warnings(&mut self) -> Option<EvalWarnings> {
        (**self).take_eval_warnings()
    }

    #[inline]
    fn take_scanned_cone(&mut self) -> IntervalCone {
        (**self).take_scanned_cone()
    }

    #[inline]
    fn can_be_cached(&self) -> bool {
        (**self).can_be_cached()
    }
}

#[causet(test)]
pub mod tests {
    use super::{FreeDaemon, BlockScanFreeDaemon};
    use codec::prelude::NumberEncoder;
    use ekvproto::interlock::KeyCone;
    use milevadb_query_common::causet_storage::test_fixture::FixtureStorage;
    use milevadb_query_datatype::codec::{datum, Block, Datum};
    use milevadb_query_datatype::expr::EvalContext;
    use milevadb_query_datatype::{FieldTypeAccessor, FieldTypeTp};
    use violetabftstore::interlock::::collections::HashMap;
    use violetabftstore::interlock::::map;
    use fidel_timeshare::PrimaryCausetInfo;
    use fidel_timeshare::BlockScan;
    use fidel_timeshare::{Expr, ExprType};

    pub fn build_expr(tp: ExprType, id: Option<i64>, child: Option<Expr>) -> Expr {
        let mut expr = Expr::default();
        expr.set_tp(tp);
        if tp == ExprType::PrimaryCausetRef {
            expr.mut_val().write_i64(id.unwrap()).unwrap();
        } else {
            expr.mut_children().push(child.unwrap());
        }
        expr
    }

    pub fn new_col_info(cid: i64, tp: FieldTypeTp) -> PrimaryCausetInfo {
        let mut col_info = PrimaryCausetInfo::default();
        col_info.as_mut_accessor().set_tp(tp);
        col_info.set_PrimaryCauset_id(cid);
        col_info
    }

    // the first PrimaryCauset should be i64 since it will be used as Evcausetidx handle
    pub fn gen_Block_data(
        tid: i64,
        cis: &[PrimaryCausetInfo],
        events: &[Vec<Datum>],
    ) -> Vec<(Vec<u8>, Vec<u8>)> {
        let mut kv_data = Vec::new();
        let col_ids: Vec<i64> = cis.iter().map(|c| c.get_PrimaryCauset_id()).collect();
        for cols in events.iter() {
            let col_values: Vec<_> = cols.to_vec();
            let value =
                Block::encode_row(&mut EvalContext::default(), col_values, &col_ids).unwrap();
            let key = Block::encode_row_key(tid, cols[0].i64());
            kv_data.push((key, value));
        }
        kv_data
    }

    pub fn get_point_cone(Block_id: i64, handle: i64) -> KeyCone {
        let spacelike_key = Block::encode_row_key(Block_id, handle);
        let mut lightlike = spacelike_key.clone();
        milevadb_query_common::util::convert_to_prefix_next(&mut lightlike);
        let mut key_cone = KeyCone::default();
        key_cone.set_spacelike(spacelike_key);
        key_cone.set_lightlike(lightlike);
        key_cone
    }

    #[inline]
    pub fn get_cone(Block_id: i64, spacelike: i64, lightlike: i64) -> KeyCone {
        let mut key_cone = KeyCone::default();
        key_cone.set_spacelike(Block::encode_row_key(Block_id, spacelike));
        key_cone.set_lightlike(Block::encode_row_key(Block_id, lightlike));
        key_cone
    }

    pub struct BlockData {
        pub kv_data: Vec<(Vec<u8>, Vec<u8>)>,
        // expect_rows[row_id][PrimaryCauset_id]=>value
        pub expect_rows: Vec<HashMap<i64, Vec<u8>>>,
        pub cols: Vec<PrimaryCausetInfo>,
    }

    impl BlockData {
        pub fn prepare(key_number: usize, Block_id: i64) -> BlockData {
            let cols = vec![
                new_col_info(1, FieldTypeTp::LongLong),
                new_col_info(2, FieldTypeTp::VarChar),
                new_col_info(3, FieldTypeTp::NewDecimal),
            ];

            let mut kv_data = Vec::new();
            let mut expect_rows = Vec::new();

            for handle in 0..key_number {
                let Evcausetidx = map![
                    1 => Datum::I64(handle as i64),
                    2 => Datum::Bytes(b"abc".to_vec()),
                    3 => Datum::Dec(10.into())
                ];
                let mut ctx = EvalContext::default();
                let mut expect_row = HashMap::default();
                let col_ids: Vec<_> = Evcausetidx.iter().map(|(&id, _)| id).collect();
                let col_values: Vec<_> = Evcausetidx
                    .iter()
                    .map(|(cid, v)| {
                        let f = Block::flatten(&mut ctx, v.clone()).unwrap();
                        let value = datum::encode_value(&mut ctx, &[f]).unwrap();
                        expect_row.insert(*cid, value);
                        v.clone()
                    })
                    .collect();

                let value = Block::encode_row(&mut ctx, col_values, &col_ids).unwrap();
                let key = Block::encode_row_key(Block_id, handle as i64);
                expect_rows.push(expect_row);
                kv_data.push((key, value));
            }
            Self {
                kv_data,
                expect_rows,
                cols,
            }
        }

        pub fn get_prev_2_cols(&self) -> Vec<PrimaryCausetInfo> {
            let col1 = self.cols[0].clone();
            let col2 = self.cols[1].clone();
            vec![col1, col2]
        }

        pub fn get_col_pk(&self) -> PrimaryCausetInfo {
            let mut pk_col = new_col_info(0, FieldTypeTp::Long);
            pk_col.set_pk_handle(true);
            pk_col
        }
    }

    pub fn gen_Block_scan_executor(
        tid: i64,
        cis: Vec<PrimaryCausetInfo>,
        raw_data: &[Vec<Datum>],
        key_cones: Option<Vec<KeyCone>>,
    ) -> Box<dyn FreeDaemon<StorageStats = ()> + lightlike> {
        let Block_data = gen_Block_data(tid, &cis, raw_data);
        let causet_storage = FixtureStorage::from(Block_data);

        let mut Block_scan = BlockScan::default();
        Block_scan.set_Block_id(tid);
        Block_scan.set_PrimaryCausets(cis.into());

        let key_cones = key_cones.unwrap_or_else(|| vec![get_cone(tid, 0, i64::max_value())]);
        Box::new(
            BlockScanFreeDaemon::Block_scan(
                Block_scan,
                EvalContext::default(),
                key_cones,
                causet_storage,
                false,
            )
            .unwrap(),
        )
    }
}
